@model List<IconConfigurationDTO>
@{
    ViewData["Title"] = "DigitalHub";
    var totalSecForOrder1And2 = (Model
    .Where(x => x.IconType == IconTypeEnum.BGVideo).OrderBy(x=>x.OrderNo).Take(1)
    .Sum(x => x.VideoDisplaySec)+1) * 1000;
}

<div class="video-container" tabindex="0">

    @await Html.PartialAsync("~/views/shared/components/homepage/header.cshtml", Model)

    @await Html.PartialAsync("~/views/shared/components/homepage/BGVideo.cshtml", Model.Where(x => x.IconType == IconTypeEnum.BGVideo).ToList())

    @await Html.PartialAsync("~/views/shared/components/homepage/Icons.cshtml", Model.Where(x => x.IconType == IconTypeEnum.Icon).ToList())

</div>

<div>
    @await Html.PartialAsync("~/views/shared/components/homepage/Footer.cshtml")
</div>


<div class="">
</div>
<script>

    document.addEventListener("DOMContentLoaded", function() {
        const revealDelay = @totalSecForOrder1And2;
         
        function showHiddenElements() { 
            const elementsToShow = document.querySelectorAll('#leftColumn, #rightColumn, .news-strip, .fix-icon, .top-strip,#ib-button-messaging');

            elementsToShow.forEach(el => {
                el.classList.add('visible-content');
            }); 
        }
         
        if (revealDelay > 0) {
            setTimeout(showHiddenElements, revealDelay);
        } else { 
            showHiddenElements();
        }
    });

       function applyCurve(columnSelector, side = 'left') {
        const column = document.querySelector(columnSelector);
        if (!column) return;

        const items = Array.from(column.children);
        const n = items.length;
        const amplitude = Math.min(140, window.innerHeight * 0.10); // stronger curve
        const rotationFactor = 12; // degrees
        const center = (n - 1) / 2;

        items.forEach((item, i) => {
            // normalized -1 to +1
            const t = (i - center) / center || 0;

            // Smooth C curve shape (cosine curve)
            const curve = -(1 - Math.cos(t * Math.PI)) / 2;
            // curve is always negative (C → ), so we flip for right column

            // Left column → C shape (inward)
            // Right column → reverse C (inward)
            const direction = (side === 'left') ? 1 : -1;

            const tx = direction * (curve * amplitude);

            // Rotation: tilt slightly inwards
            const rot = direction * (t * rotationFactor);

            item.style.setProperty('--tx', Math.round(tx) + 'px');
            item.style.setProperty('--rot', 0 + 'deg');
           // item.style.setProperty('--rot', rot.toFixed(2) + 'deg');
        });
    }


    function applyAllCurves() {
        applyCurve('#leftColumn', 'right');
        applyCurve('#rightColumn', 'left');
    }

    window.addEventListener('load', applyAllCurves);
    window.addEventListener('resize', () => {
        clearTimeout(window._curveResizeTimer);
        window._curveResizeTimer = setTimeout(applyAllCurves, 120);
    });







</script>